# Stage 1 知识点与用例意义

## 一、Stage 1 在讲什么（知识点）

Stage 1 解决的是：**「和模型聊多轮时，你手里那堆消息该怎么存、怎么裁、怎么喂给 API」**。对应几个核心概念：

### 1. Session / 会话边界

一次对话用一个 `sessionId`，里面存整条 `messages` 链。多用户、多对话就多个 session，互不串线。这是「对话」和「单次请求」之间的抽象层。

### 2. 消息角色与顺序

`system` / `user` / `assistant` 三条线，和 Stage 0（以及常见 Chat API）一致。Context Engine 只负责「按顺序存、按顺序取」，不解释内容；取出来的 `Message[]` 直接给 Gateway 发 `chat(messages)`。

### 3. 上下文窗口裁剪（trim）

模型有 token 上限，对话长了必须「丢一些旧消息」。Stage 1 做了两件事：

- **按量裁**：`maxTokens`（用 chars/4 粗算）、`maxMessages`（条数）。
- **按策略裁**：`drop_oldest`（从最老开始丢）或 `keep_system_and_recent`（尽量保留 system + 最近几轮）。

这样你就不用每次自己写「保留哪几条、丢哪几条」的逻辑。

### 4. 摘要记忆（summary memory）

长对话不能只靠「丢旧消息」，否则模型会忘掉前半段。做法是：对已经裁掉的那段历史，用文字概括成一条 `summary`，在下次请求时以 **一条 system 消息** 的形式放在最前面（"Previous context summary: …"）。模型看到的仍是「系统设定 + 摘要 + 最近几轮」，既省 token 又保留长期信息。

### 5. 与 Stage 0 的分工

Stage 0 只管「发一次请求、拿一次回复」。Stage 1 管「多轮对话的状态」：存历史、裁长度、加摘要，然后 **产出** 当前这次请求该用的 `messages`，再交给 Stage 0 去 `chat`。所以：**Context Engine 决定「给模型看什么」；Gateway 决定「怎么发、怎么重试、怎么计费」。**

---

## 二、用例在演示什么（用例的意义）

`basic-usage.ts` 按「从状态到请求」的顺序，把上面这些点串成一条可跑的流程：

| 步骤 | 输出里你看到的 | 在学什么 |
|------|----------------|----------|
| 创建 engine + session | `Session created: sess_...` | 会话以 sessionId 为界，engine 内维护 session 存储。 |
| 写入 4 条消息（1 system + 2 轮 user/assistant） | `Messages for request (count): 4` 和每条 role/content | 历史是**按顺序追加**的；取出来就是「要发给模型的列表」。 |
| `getMessagesForRequest(..., includeSummaryAsSystem: false)` | 4 条，没有摘要 | 裁剪/摘要都是**可配置**的；这里先看「纯历史」长什么样。 |
| `setSummary` + 再取 `getMessagesForRequest(..., includeSummaryAsSystem: true)` | `With summary as system (count): 5`，第一条是 "Previous context summary: User asked simple math..." | **摘要** 被当成一条 system 消息插在最前面；模型既看到「之前聊了啥」的压缩版，又看到最近几轮原文。 |
| 用 `replyMessages` 调 Gateway | 请求日志 + 回复 "3 + 3 equals 6." | Context Engine **产出** 的 `Message[]` 直接给 Stage 0 用，形成「context 层 → gateway 层」的调用关系。 |
| `addMessage(sessionId, assistantReply)` | `Session message count: 5` | 模型的回复要**写回**同一 session，下一轮请求时就会带上这轮，实现真正的多轮对话。 |

所以：**用例的意义** = 用一段最短的脚本，把「建会话 → 写历史 → 裁剪/摘要 → 交给 Gateway 请求 → 把回复写回会话」这条闭环跑通，让你看到 Stage 1 的每个概念在运行时的效果（尤其是「带 summary 时多了一条 system」和「最后 message count 变成 5」）。

---

## 三、一句话对照

- **知识点**：Session 存对话、角色分 system/user/assistant、按 token/条数裁剪、用 summary 压缩旧历史，并且 Context Engine 只负责「准备好 messages」，真正发请求的是 Stage 0。
- **用例意义**：用一次运行把「存 → 裁 → 加摘要 → 调 Gateway → 写回」全走一遍，把 Stage 1 的抽象和 Stage 0 的调用连起来，方便你以后做长对话、多 session 或多轮 Agent 时直接复用这一套思路。