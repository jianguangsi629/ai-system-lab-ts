# Stage 2 知识点与用例意义

本文档归纳 Stage 2（Output Control）的核心知识点，以及 `examples/basic-usage.ts` 的用意与可借鉴之处。

---

## 一、Stage 2 在讲什么（知识点）

Stage 2 解决的是：**「模型返回的是一坨文本，你怎么把它变成可信的结构化数据」**。对应几个核心概念：

### 1. LLM 视为不可信计算节点

模型输出可能：不是 JSON、JSON 缺字段、类型错（如把年龄写成字符串）、附带说明文字等。因此**一律不直接信任**：先解析、再按 schema 校验，通过后才当结构化结果用。这是「输出控制」的语义前提。

### 2. 结构化输出与 JSON Schema

用 **JSON Schema**（如 `type: "object"`, `properties`, `required`, `additionalProperties`）描述「期望的形状」。上层定义 schema，Output Controller 负责：从原始 `content` 里抽出 JSON → 用 ajv 校验 → 返回 `ParseResult<T>`（成功则 `data`，失败则 `errors`）。这样业务层拿到的要么是类型安全的 `T`，要么是明确的错误信息，便于重试或降级。

### 3. 解析策略（从原始内容里抽 JSON）

模型经常返回 Markdown 代码块（\`\`\`json ... \`\`\`）或「一段话 + 一个 JSON」。Stage 2 的解析层做了两件事：

- **剥代码块**：若内容以 \`\`\`json ... \`\`\` 包裹，先剥掉再解析，避免把 markdown 当 JSON。
- **取首段 JSON**：在正文中找第一个 `{...}` 或 `[...]`，按括号匹配截取一段，再 `JSON.parse`，这样模型在 JSON 前后加的解释不会污染解析。

### 4. 校验与错误信息

校验用 **ajv** 做，支持 JSON Schema draft-07 等。校验失败时收集 `instancePath`、`message`、`params`，转成可读的 `errors: string[]` 返回，便于日志或提示「哪一栏不符合 schema」。

### 5. 与 Stage 0 / Stage 1 的分工

- **Stage 0**：只负责「发请求 → 拿 `content` 字符串」。
- **Stage 1**：负责「多轮对话的 messages 从哪来、怎么裁、怎么加摘要」。
- **Stage 2**：负责「拿到 `content` 之后，怎么解析、怎么校验、怎么产出可信的 `T`」。

所以：**Gateway 给的是 raw text；Output Controller 给的是 parsed + validated 的结构化结果，或明确错误。** 三者串联即：Context Engine 准备 messages → Gateway 调模型拿 content → Output Controller 把 content 变成 `ParseResult<T>`。

---

## 二、用例在演示什么（用例的意义）

`basic-usage.ts` 分两块：先**本地解析/校验**（不调模型），再**完整流水线**（Context Engine + Gateway + Output Controller）。

| 步骤                                                                                               | 输出里你看到的                                                  | 在学什么                                                                                                                                             |
| -------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| 用「好」的字符串 `\`\`\`json\n{"name": "Alice", "age": 30}\n\`\`\`` 调 `parseAndValidate`          | `Parsed (good): { name: 'Alice', age: 30 }`                     | **代码块**被正确剥掉，JSON 解析通过，schema 校验通过；说明「模型按约定返回时」整条链路是通的。                                                       |
| 用「坏」的字符串 `{"name": "Bob", "age": "not a number"}` 调 `parseAndValidate`                    | `Validation failed (expected): [ '/age must be number (...)' ]` | **类型不符**（age 应为 number）被 ajv 检出；说明 LLM 乱写时我们**不信任**，直接返回错误，业务可重试或降级。                                          |
| 建 session、写 system（要求只返回 JSON）+ 一条 user（"My name is Charlie and I am 28 years old."） | 请求日志（requestId、model、provider、messageCount）            | 用 **Stage 1** 准备 messages，用 **Stage 0** 发一次 chat；和 Stage 1 用例一样，只是这次**期望**回复是结构化 JSON。                                   |
| 用 `chatResult.content` 调 `parseAndValidate(..., { schema: PERSON_SCHEMA })`                      | `Structured output from LLM: { name: 'Charlie', age: 28 }`      | Gateway 返回的**原始文本**经过 Output Controller 解析与校验，变成可信的 `{ name, age }`；若解析或校验失败，会走 `errors` 分支并可选打印 `raw` 片段。 |
| 成功时 `engine.addMessage(sessionId, assistantReply)`                                              | （无额外输出，但 session 中多了一条 assistant）                 | 和 Stage 1 一致：**通过校验的回复**才写回 session，下一轮对话会带上；若校验失败可以不写回，避免把脏数据当历史。                                      |

所以：**用例的意义** = 先用两段固定字符串把「解析 + 校验」的好/坏路径跑通，再用「Context Engine → Gateway → Output Controller」把「多轮里的一次结构化请求」跑通，让你看到 Stage 2 的「不信任 raw、必过 schema」在运行时的效果（尤其是「好 JSON 出 data、坏 JSON 出 errors」和「真实模型返回被解析成 Charlie / 28」）。

---

## 三、小结与一句话对照

| 维度     | 要点                                                                                                                                |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 定位     | 输出控制层：把 LLM 的 raw content 解析成 JSON，再按 JSON Schema 校验，产出可信的 `T` 或明确错误。                                   |
| 语义     | LLM 为不可信节点；只有 parse + validate 都通过才使用；失败返回 `errors`，便于重试或降级。                                           |
| 解析     | 支持剥 \`\`\`json ... \`\`\`、取正文中第一个 `{...}`/`[...]`，兼容模型附带说明。                                                    |
| 校验     | 使用 ajv + JSON Schema；错误信息转成可读的 `string[]`。                                                                             |
| 与上下游 | Stage 1 产 messages → Stage 0 产 content → Stage 2 产 `ParseResult<T>`。                                                            |
| 案例价值 | 先演示「好/坏」字符串的解析与校验，再演示「Context + Gateway + Output Control」完整流，把 Stage 2 的抽象和 Stage 0/1 的调用连起来。 |

- **知识点**：LLM 输出不直接信任；用 JSON Schema 约束形状；先解析（剥代码块、取首段 JSON）再校验（ajv）；Output Controller 只负责 `parseAndValidate(content, options)` → `ParseResult<T>`；与 Stage 0/1 串联成「准备消息 → 调模型 → 产出结构化结果」。
- **用例意义**：用一次运行把「本地好/坏样例的解析与校验」和「真实多轮里的一次结构化请求（Context Engine + Gateway + Output Controller）」都走一遍，方便你在做抽取、表单、结构化回复或多步 Agent 时直接复用「先解析再校验、失败就 errors」这一套思路。

以上内容可直接用于复习 Stage 2 或向他人说明本阶段的设计与示例用途。
