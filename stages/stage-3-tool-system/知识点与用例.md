# Stage 3 知识点与用例意义

本文档归纳 Stage 3（Tool System）的核心知识点，以及 `examples/basic-usage.ts` 的用意与可借鉴之处。

---

## 一、Stage 3 在讲什么（知识点）

Stage 3 解决的是：**「模型如何决定是否调用工具、如何执行工具、如何把结果回注给模型」**。对应几个核心概念：

### 1. Tool 抽象

每个工具是一个 **Tool**：`name`（唯一标识）、`description`（给模型看的说明）、`parameters`（可选 JSON Schema 描述参数）、`execute(args)`（异步执行函数）。与具体 LLM API 的 function calling 格式解耦，便于以后对接 OpenAI / Claude 等原生 tool_calls 时只改「请求/响应转换」层，不改业务工具定义。

### 2. Tool Registry（工具注册中心）

**ToolRegistry** 负责：`register(tool)` 按 name 注册、`get(name)` 按名查找、`list()` 列出全部（用于拼 system prompt 或未来 API 的 tools 数组）、`execute(name, args)` 按名执行并返回结果。所有工具集中在一个 registry 里，上层（如 runner）只依赖 registry，不关心工具从哪来。

### 3. LLM 决策：当前为「结构化输出」方式

当前实现采用 **prompt-based**：在 system prompt 中列出所有工具的 name、description、parameters，要求模型**仅返回一个 JSON 对象**，且只能是两种之一：

- **调用工具**：`{ "tool": "<name>", "arguments": { ... } }`
- **不调用、直接回复**：`{ "tool": null, "reply": "..." }`

这样「是否调用、调用哪个、参数是什么」都由模型在**一次**回复里决定，我们用 Stage 2 的 Output Controller 解析并校验该 JSON（`TOOL_DECISION_SCHEMA`），得到可信的 `ToolDecisionOutput`。模型仍被视为不可信节点：解析/校验失败就不执行工具，可记录错误或重试。

### 4. 工具执行与结果回注

解析出 `tool` 非 null 时，用 **ToolRegistry.execute(name, arguments)** 执行；执行结果（或错误信息）转成字符串，以一条 **user 消息** 形式追加到会话，例如：`[Tool result for get_weather]\n{"city":"Shanghai","temp":22,"unit":"celsius"}`。然后再次请求模型，模型看到这条「工具结果」后可以继续决定：再调一次工具，或返回 `tool: null, reply: "..."` 作为最终回复。这样形成「模型 → 解析 → 执行 → 回注 → 模型」的循环。

### 5. runToolLoop 与依赖

**runToolLoop(deps, sessionId, userMessage, options)** 串联整条链路：

- **deps**：`chat`（Stage 0 Gateway.chat）、`contextEngine`（Stage 1）、`outputController`（Stage 2）、`toolRegistry`（Stage 3）。
- 在 session 里先写入「带工具描述的 system prompt」和「用户本轮消息」。
- 循环：取 messages → chat → 解析 content 为 ToolDecisionOutput；若 `tool` 为 null 则结束并返回 `reply`；否则执行工具、把结果当 user 消息追加、再 chat，直到 `tool` 为 null 或达到 `maxToolRounds`。

因此：**Tool System 依赖 Stage 0 / 1 / 2**；Stage 3 只负责「工具抽象 + 注册 + 决策解析 + 执行 + 回注循环」，不负责发 HTTP 或管上下文窗口，职责清晰。

### 6. 与「原生 tool_calls」的关系

若未来网关支持原生 function calling（如 OpenAI `tool_calls`、Claude tools），可以在 Stage 3 增加一层：把 **ToolRegistry.list()** 转成 API 要求的 tools 数组，把 API 返回的 tool_calls 转成 `(name, arguments)` 仍用 **Registry.execute** 执行，再把结果按 API 要求格式写回 messages。这样「工具定义与执行」仍在 Stage 3，「请求/响应格式」可替换为原生，业务侧工具代码不变。

---

## 二、用例在演示什么（用例的意义）

`basic-usage.ts` 分两块：先**仅 Registry + 本地执行**（不调模型），再**完整流水线**（Context Engine + Gateway + Output Controller + runToolLoop）。

| 步骤                                                                                                                                | 输出里你看到的                                                             | 在学什么                                                                                                                                                                                                                              |
| ----------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 创建 Registry，注册 `get_weather`、`get_time`                                                                                       | `Registered tools: [ 'get_weather', 'get_time' ]`                          | **Tool 抽象**：name、description、parameters、execute；**Registry**：register、list。                                                                                                                                                 |
| 直接 `registry.execute("get_weather", { city: "Beijing" })`                                                                         | `Direct tool call get_weather(Beijing): { city, temp, unit }`              | 不经过模型，验证「工具可被按名执行」；与 Stage 2 的「本地好/坏样例」同理，先确认执行层正确。                                                                                                                                          |
| 直接 `registry.execute("get_time", {})`                                                                                             | `Direct tool call get_time(): <ISO date string>`                           | 无参工具也能正常执行。                                                                                                                                                                                                                |
| 组装 deps（gateway.chat、contextEngine、outputController、toolRegistry），调用 `runToolLoop(deps, sessionId, userMessage, options)` | 请求日志、最终 `Assistant reply: ...`、`Tool rounds executed: 1`（或更多） | **完整工具循环**：用户问「What is the weather in Shanghai?」→ 模型返回 JSON 决定调用 `get_weather` → 我们解析、执行、把结果当 user 消息回注 → 模型再返回 `tool: null, reply: "..."`；你看到「LLM 决策 → 执行 → 回注」在运行时的效果。 |
| 若模型某轮返回非法 JSON 或校验失败                                                                                                  | `result.reply` 为 undefined，`lastRawContent` 有值                         | 与 Stage 2 一致：**不信任 raw**，解析/校验失败就不继续执行工具，避免脏数据驱动工具调用。                                                                                                                                              |

所以：**用例的意义** = 先用「仅 Registry + 本地执行」把工具定义与执行跑通，再用「Context Engine + Gateway + Output Controller + runToolLoop」把「用户提问 → 模型决定调用工具 → 执行 → 回注 → 模型最终回复」跑通，让你看到 Stage 3 的「Tool 抽象、Registry、结构化决策、结果回注」在真实多轮中的效果。

---

## 三、小结与一句话对照

| 维度     | 要点                                                                                                                                                                 |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 定位     | 工具系统层：定义 Tool 抽象、Tool Registry，实现「LLM 决策是否调用工具」与「工具执行结果回注」。                                                                      |
| 语义     | 当前为 prompt-based：system 中描述工具，模型仅返回 JSON（tool + arguments 或 tool: null + reply）；解析与校验用 Stage 2，执行用 Registry，回注以 user 消息形式追加。 |
| 与上下游 | Stage 1 产 messages，Stage 0 产 content，Stage 2 产 ToolDecisionOutput，Stage 3 负责工具注册、执行、回注与 runToolLoop 循环。                                        |
| 案例价值 | 先演示「Registry + 本地执行」确认工具层正确，再演示「完整 Tool Loop」把 Stage 0/1/2/3 串联，看到模型决定调工具、执行、回注、最终回复的整条链路。                     |

- **知识点**：Tool 抽象（name、description、parameters、execute）；Tool Registry（register、get、list、execute）；LLM 决策当前为「结构化输出」解析为 ToolDecisionOutput；工具执行结果以 user 消息回注；runToolLoop 串联 Gateway / Context Engine / Output Controller / Registry；未来可替换为原生 tool_calls 而保留工具定义与执行。
- **用例意义**：用一次运行把「Registry + 本地执行」和「完整 prompt-based 工具循环」都走一遍，方便你在做问答+查天气/查时间、或多步 Agent 时直接复用「注册工具 → 模型决策 → 执行 → 回注」这一套思路。

以上内容可直接用于复习 Stage 3 或向他人说明本阶段的设计与示例用途。
