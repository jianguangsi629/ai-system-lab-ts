# Stage 0 知识点与案例总结

本文档归纳 Stage 0（Model Gateway）的核心知识点，以及 `examples/basic-usage.ts` 的用意与可借鉴之处。

---

## 一、知识点总结

### 1. 定位与边界

- **Stage 0 是什么**：多厂商 LLM 的统一接入层，只做「发请求 → 拿回复」的可靠性与可观测性。
- **不做什么**：不处理记忆、结构化输出校验、工具调用、Agent 逻辑；`raw` 仅透传，不解释业务含义。

### 2. 请求流水线（顺序语义）

约定执行顺序：

```
request → 分配 requestId → withTimeout(withRetry(callProvider)) → logResponse → estimateCost
```

- **Timeout**：单次尝试的硬上限，用 `AbortController` 与请求的 `abortSignal` 合并。
- **Retry**：对「单次尝试」的包装；只有可重试错误（429、5xx、AbortError、ETIMEDOUT 等）才重试，且有次数与退避上限。
- **raw 铁律**：Gateway 不解析 `raw`，只负责透传，便于上层做 debug/audit/replay。

### 3. 统一抽象

- **消息格式**：`Message` 仅 `role: system | user | assistant` + `content: string`。
- **Provider 适配器**：`LLMProvider` 接口统一 `chat(request) => Promise<ChatResult>`，各厂商在适配器内转成各自 API 形态。
- **模型与厂商映射**：通过 `modelProviderMap`（如 `"deepseek-chat" → "deepseek"`）由模型名解析出 Provider，请求可省略 `provider`。

### 4. 可靠性与降级

- **重试策略**：`maxRetries`、`backoffMs`、`maxBackoffMs`、`jitter`；仅对 `ProviderError` 的 429/5xx、`AbortError`、部分网络错误码判定为可重试。
- **Fallback 模型**：主模型失败后，按 `fallbackModels` 顺序换模型重试，实现降级而不改业务接口。

### 5. 可观测性

- **请求/响应/错误日志**：`RequestLogger` 三方法 `logRequest`、`logResponse`、`logError`，便于排查与审计。
- **成本估算**：基于 `Usage`（input/output tokens）和 `CostTable`（每千 token 单价）算 `CostEstimate`（inputCents、outputCents、totalCents），不依赖厂商返回价格。

### 6. 配置与扩展

- **GatewayConfig**：显式配置 `providers`、`defaultModel`、`modelProviderMap`、`fallbackModels`、`timeoutMs`、`retry`、可选 `logger`/`costTable`。
- **全局配置**：根目录 `config/` 提供 `loadGlobalConfig`、`buildProviderConfigFromModelMaps` 等，从环境变量/配置生成 Provider 与模型映射，便于多环境复用。

---

## 二、案例的意义（`examples/basic-usage.ts`）

### 1. 演示完整闭环

- 用**全局配置**（`buildProviderConfigFromModelMaps`、`getDefaultModelFromMaps`、`getModelProviderMapFromModelMaps`、`getFallbackModelsFromMaps`）组一个可直接运行的 Gateway，而不是手写 API Key 和映射。
- 一次 `gateway.chat(...)` 覆盖：模型解析 → 超时 → 重试 → 主/备模型降级 → 日志 → 成本估算。

### 2. 展示返回结构的使用方式

- **必用**：`result.content` 作为助手回复文本。
- **可选**：`result.usage`（token 统计）、`result.cost`（inputCents、outputCents、totalCents、currency），便于做用量监控与成本展示。
- 说明上层只需依赖 `ChatResult` 的稳定字段，无需关心厂商或 `raw`。

### 3. 作为接入后续 Stage 的模板

- 后续 Stage（如 Context Engine、Output Control、Tool、Agent）都会依赖「一次 chat 调用拿到 content + usage + cost」。
- 本示例相当于「最小可运行客户端」：换 messages、temperature、model 即可复用到其他 stage 的演示或测试里。

### 4. 与 README 的配合

- README 中的「使用示例」是片段；`basic-usage.ts` 是可执行完整版，且包含错误处理（`main().catch(...)`）和 exitCode，便于直接 `npm run stage:0` 验证环境与配置是否正确。

---

## 三、小结

| 维度     | 要点                                                               |
| -------- | ------------------------------------------------------------------ |
| 架构     | 应用 → Gateway（重试/超时/日志/成本/Provider 选择）→ 厂商 API      |
| 语义     | 顺序固定；timeout 是机制，retry 是策略；raw 只透传                 |
| 抽象     | 统一 Message/ChatRequest/ChatResult、LLMProvider、modelProviderMap |
| 可靠性   | 可重试错误 + 退避与 jitter；fallback 模型降级                      |
| 可观测   | RequestLogger、CostTable + estimateCost                            |
| 案例价值 | 展示配置到调用的闭环、返回结构用法、以及作为后续 Stage 的调用模板  |

以上内容可直接用于复习 Stage 0 或向他人说明本阶段的设计与示例用途。
